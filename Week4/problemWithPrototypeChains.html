<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //原型链的主要问题来自包含引用类型值的原型。前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。

        function SuperType() {
            this.colors = ['red', 'blue', 'green'];
        }

        function SubType() {

        }

        //继承了 SubType
        SubType.prototype = new SubperType();

        var instance1 = new SubType();

        instance1.colors.push('black');
        alert(instance1.colors);    //'red,blue,green,black'

        var instance2 = new SubType();
        alert(instance2.colors);    //'red,blue,green,black'
        
        //原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。
    </script>
</body>
</html>