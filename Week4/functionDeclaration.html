<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //关于函数声明，它的一个重要特征就是函数声明提升（Function declaration hoisting）,意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面

        sayHi();
        function sayHi() {
            alert('Hi');
        }

        //函数表达式
        var functionName = function(arg0, arg1, arg2) {
            //函数体
        };
        //这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 functionName。这种情况下创建的函数叫做匿名函数（anoymous function），因为 function 关键字后面没有标识符（匿名函数有时候也叫拉姆达函数。）匿名函数的 name 属性是空字符串。
        //函数表达式与其他表达式一样，在使用前必须先赋值。

        // sayHi(); //错误，函数还不存在
        // var sayHi = function() {
        //     alert('Hi');
        // };
        
        //不要这样做
        // if (condition) {
        //     function sayHi() {
        //         alert('Hi');
        //     }
        // } else {
        //     function sayHi() {
        //         alert('Yo');
        //     }
        // }

        //实际上，这在 ECMAScript 中属于无效语法，Javascript 引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition

        //使用函数表达式，没问题
        var sayHi;

        if(condition) {
            sayHi = function() {
                alert('Hi!');
            };
        } else {
            sayHi = function() {
                alert('Yo!');
            }
        }

        //能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回

        function createComparisonFunction(propertyName) {
            
            return function(object1,object2) {
                var value1 = object1[propertyName];
                var value2 = object2[propertyName];

                if(value1 < value2) {
                    return -1;
                } else if (value1 > value2) {
                    return 1;
                } else {
                    return 0;
                }
            };
        }
    </script>
</body>
</html>