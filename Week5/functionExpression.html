<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //定义函数方式有两种：一种是函数声明，另一种就是函数表达式
        //函数声明语法
        function functionName(arg0, arg1, arg2) {}

        //函数声明，它的一个重要特征就是函数声明提升(function declaration hoisting)，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面
        sayHi();
        function sayHi() {
            alert('Hi');
        }

        //第二种创建函数的方式就是使用函数表达式。
        var functionName = function(arg0, arg1, arg2) {
            //函数体
        };
        //创建一个匿名函数，并将它赋值给变量 functionName

        // sayHi(); 错误：函数还不存在
        // var sayHi = function() {
            // alert('Hi');
        // };

        if(condition) {
            function sayHi() {
                alert('Hi!');
            }
        } else {
                function sayHi() {
                    alert('Yo!');
                }
            }
        //以上代码表示在 condition 为 true时，使用一个 sayHi() 的定义；否则，就使用另一个定义。实际上，这在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合理的状态。。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition；Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险，不应该出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。

        //可以这样做
        var sayHi;

        if(condition) {
            var sayHi = function() {
                alert('Hi!');
            }
        } else {
               var sayHi = function sayHi() {
                    alert('Yo!');
                }
            }

            //能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。
            function createComparisonFunction(propertyName) {
                
                return function(object1, object2) {
                    var value1 = object1[propertyName];
                    var value2 = object2[propertyName];

                    if (value1 < value2) {
                        return -1;
                    } else if (value1 > value2) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
            }
            //createComparisonFunction() 就返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过，在 createComparisonFunction() 函数内部，它是匿名的。在把函数当成值来使用的情况下，都可以使用匿名函数。
    </script>
</body>
</html>